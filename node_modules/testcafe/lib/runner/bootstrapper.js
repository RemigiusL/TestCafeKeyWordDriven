"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const compiler_1 = __importDefault(require("../compiler"));
const connection_1 = __importDefault(require("../browser/connection"));
const runtime_1 = require("../errors/runtime");
const pool_1 = __importDefault(require("../browser/provider/pool"));
const types_1 = require("../errors/types");
const browser_set_1 = __importDefault(require("./browser-set"));
const tested_app_1 = __importDefault(require("./tested-app"));
const parse_file_list_1 = __importDefault(require("../utils/parse-file-list"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const make_dir_1 = __importDefault(require("make-dir"));
const resolve_path_relatively_cwd_1 = __importDefault(require("../utils/resolve-path-relatively-cwd"));
const load_1 = __importDefault(require("../custom-client-scripts/load"));
const utils_1 = require("../custom-client-scripts/utils");
class Bootstrapper {
    constructor(browserConnectionGateway) {
        this.browserConnectionGateway = browserConnectionGateway;
        this.concurrency = null;
        this.sources = [];
        this.browsers = [];
        this.reporters = [];
        this.filter = null;
        this.appCommand = null;
        this.appInitDelay = null;
        this.tsConfigPath = null;
        this.clientScripts = [];
    }
    static _splitBrowserInfo(browserInfo) {
        const remotes = [];
        const automated = [];
        browserInfo.forEach(browser => {
            if (browser instanceof connection_1.default)
                remotes.push(browser);
            else
                automated.push(browser);
        });
        return { remotes, automated };
    }
    async _getBrowserInfo() {
        if (!this.browsers.length)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.browserNotSet);
        const browserInfo = await Promise.all(this.browsers.map(browser => pool_1.default.getBrowserInfo(browser)));
        return lodash_1.flatten(browserInfo);
    }
    _createAutomatedConnections(browserInfo) {
        if (!browserInfo)
            return [];
        return browserInfo
            .map(browser => lodash_1.times(this.concurrency, () => new connection_1.default(this.browserConnectionGateway, browser)));
    }
    async _getBrowserConnections(browserInfo) {
        const { automated, remotes } = Bootstrapper._splitBrowserInfo(browserInfo);
        if (remotes && remotes.length % this.concurrency)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotDivideRemotesCountByConcurrency);
        let browserConnections = this._createAutomatedConnections(automated);
        browserConnections = browserConnections.concat(lodash_1.chunk(remotes, this.concurrency));
        return await browser_set_1.default.from(browserConnections);
    }
    async _getTests() {
        if (!this.sources.length)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.testSourcesNotSet);
        const { parsedFileList, compilerOptions } = await this._getCompilerArguments();
        const compiler = new compiler_1.default(parsedFileList, compilerOptions);
        let tests = await compiler.getTests();
        const testsWithOnlyFlag = tests.filter(test => test.only);
        if (testsWithOnlyFlag.length)
            tests = testsWithOnlyFlag;
        if (this.filter)
            tests = tests.filter(test => this.filter(test.name, test.fixture.name, test.fixture.path, test.meta, test.fixture.meta));
        if (!tests.length)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.noTestsToRun);
        return tests;
    }
    async _getCompilerArguments() {
        const parsedFileList = await parse_file_list_1.default(this.sources, process.cwd());
        const compilerOptions = {
            typeScriptOptions: {
                tsConfigPath: this.tsConfigPath
            }
        };
        return { parsedFileList, compilerOptions };
    }
    async _ensureOutStream(outStream) {
        if (typeof outStream !== 'string')
            return outStream;
        const fullReporterOutputPath = resolve_path_relatively_cwd_1.default(outStream);
        await make_dir_1.default(path_1.default.dirname(fullReporterOutputPath));
        return fs_1.default.createWriteStream(fullReporterOutputPath);
    }
    static _addDefaultReporter(reporters) {
        reporters.push({
            name: 'spec',
            file: process.stdout
        });
    }
    async _getReporterPlugins() {
        const stdoutReporters = lodash_1.filter(this.reporters, r => lodash_1.isUndefined(r.output) || r.output === process.stdout);
        if (stdoutReporters.length > 1)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.multipleStdoutReporters, stdoutReporters.map(r => r.name).join(', '));
        if (!this.reporters.length)
            Bootstrapper._addDefaultReporter(this.reporters);
        return Promise.all(this.reporters.map(async ({ name, output }) => {
            let pluginFactory = name;
            const outStream = await this._ensureOutStream(output);
            if (typeof pluginFactory !== 'function') {
                try {
                    pluginFactory = require('testcafe-reporter-' + name);
                }
                catch (err) {
                    throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotFindReporterForAlias, name);
                }
            }
            return {
                plugin: pluginFactory(),
                outStream
            };
        }));
    }
    async _startTestedApp() {
        if (this.appCommand) {
            const testedApp = new tested_app_1.default();
            await testedApp.start(this.appCommand, this.appInitDelay);
            return testedApp;
        }
        return null;
    }
    async _canUseParallelBootstrapping(browserInfo) {
        const isLocalPromises = browserInfo.map(browser => browser.provider.isLocalBrowser(null, browserInfo.browserName));
        const isLocalBrowsers = await Promise.all(isLocalPromises);
        return isLocalBrowsers.every(result => result);
    }
    async _bootstrapSequence(browserInfo, commonClientScripts) {
        const tests = await this._getTests();
        const testedApp = await this._startTestedApp();
        const browserSet = await this._getBrowserConnections(browserInfo);
        await this._addCommonClientScripts(tests, commonClientScripts);
        return { tests, testedApp, browserSet };
    }
    _wrapBootstrappingPromise(promise) {
        return promise
            .then(result => ({ error: null, result }))
            .catch(error => ({ result: null, error }));
    }
    async _handleBootstrappingError([browserSetStatus, testsStatus, testedAppStatus]) {
        if (!browserSetStatus.error)
            await browserSetStatus.result.dispose();
        if (!testedAppStatus.error && testedAppStatus.result)
            await testedAppStatus.result.kill();
        if (testsStatus.error)
            throw testsStatus.error;
        else if (testedAppStatus.error)
            throw testedAppStatus.error;
        else
            throw browserSetStatus.error;
    }
    async _bootstrapParallel(browserInfo, commonClientScripts) {
        let bootstrappingPromises = [
            this._getBrowserConnections(browserInfo),
            this._getTests(),
            this._startTestedApp()
        ];
        bootstrappingPromises = bootstrappingPromises.map(promise => this._wrapBootstrappingPromise(promise));
        const bootstrappingStatuses = await Promise.all(bootstrappingPromises);
        if (bootstrappingStatuses.some(status => status.error))
            await this._handleBootstrappingError(bootstrappingStatuses);
        const [browserSet, tests, testedApp] = bootstrappingStatuses.map(status => status.result);
        await this._addCommonClientScripts(tests, commonClientScripts);
        return { browserSet, tests, testedApp };
    }
    async _addCommonClientScripts(tests, clientScripts) {
        return Promise.all(tests.map(async (test) => {
            if (test.isLegacy)
                return;
            let loadedTestClientScripts = await load_1.default(test.clientScripts, path_1.default.dirname(test.testFile.filename));
            loadedTestClientScripts = clientScripts.concat(loadedTestClientScripts);
            test.clientScripts = utils_1.setUniqueUrls(loadedTestClientScripts);
        }));
    }
    // API
    async createRunnableConfiguration() {
        const reporterPlugins = await this._getReporterPlugins();
        const commonClientScripts = await load_1.default(this.clientScripts);
        // NOTE: If a user forgot to specify a browser, but has specified a path to tests, the specified path will be
        // considered as the browser argument, and the tests path argument will have the predefined default value.
        // It's very ambiguous for the user, who might be confused by compilation errors from an unexpected test.
        // So, we need to retrieve the browser aliases and paths before tests compilation.
        const browserInfo = await this._getBrowserInfo();
        if (await this._canUseParallelBootstrapping(browserInfo))
            return Object.assign({ reporterPlugins }, await this._bootstrapParallel(browserInfo, commonClientScripts));
        return Object.assign({ reporterPlugins }, await this._bootstrapSequence(browserInfo, commonClientScripts));
    }
}
exports.default = Bootstrapper;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwcGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3J1bm5lci9ib290c3RyYXBwZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxtQ0FBb0U7QUFDcEUsMkRBQW1DO0FBQ25DLHVFQUFzRDtBQUN0RCwrQ0FBaUQ7QUFDakQsb0VBQTJEO0FBQzNELDJDQUFpRDtBQUNqRCxnRUFBdUM7QUFDdkMsOERBQXFDO0FBQ3JDLCtFQUFxRDtBQUNyRCxnREFBd0I7QUFDeEIsNENBQW9CO0FBQ3BCLHdEQUErQjtBQUMvQix1R0FBNEU7QUFDNUUseUVBQThEO0FBQzlELDBEQUErRDtBQUUvRCxNQUFxQixZQUFZO0lBQzdCLFlBQWEsd0JBQXdCO1FBQ2pDLElBQUksQ0FBQyx3QkFBd0IsR0FBRyx3QkFBd0IsQ0FBQztRQUN6RCxJQUFJLENBQUMsV0FBVyxHQUFnQixJQUFJLENBQUM7UUFDckMsSUFBSSxDQUFDLE9BQU8sR0FBb0IsRUFBRSxDQUFDO1FBQ25DLElBQUksQ0FBQyxRQUFRLEdBQW1CLEVBQUUsQ0FBQztRQUNuQyxJQUFJLENBQUMsU0FBUyxHQUFrQixFQUFFLENBQUM7UUFDbkMsSUFBSSxDQUFDLE1BQU0sR0FBcUIsSUFBSSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxVQUFVLEdBQWlCLElBQUksQ0FBQztRQUNyQyxJQUFJLENBQUMsWUFBWSxHQUFlLElBQUksQ0FBQztRQUNyQyxJQUFJLENBQUMsWUFBWSxHQUFlLElBQUksQ0FBQztRQUNyQyxJQUFJLENBQUMsYUFBYSxHQUFjLEVBQUUsQ0FBQztJQUN2QyxDQUFDO0lBRUQsTUFBTSxDQUFDLGlCQUFpQixDQUFFLFdBQVc7UUFDakMsTUFBTSxPQUFPLEdBQUssRUFBRSxDQUFDO1FBQ3JCLE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUVyQixXQUFXLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzFCLElBQUksT0FBTyxZQUFZLG9CQUFp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LHlHQUF5RztRQUN6RyxrRkFBa0Y7UUFDbEYsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7UUFFakQsSUFBSSxNQUFNLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxXQUFXLENBQUM7WUFDcEQsdUJBQVMsZUFBZSxJQUFLLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxtQkFBbUIsQ0FBQyxFQUFHO1FBRW5HLHVCQUFTLGVBQWUsSUFBSyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsbUJBQW1CLENBQUMsRUFBRztJQUNuRyxDQUFDO0NBQ0o7QUFqUEQsK0JBaVBDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNVbmRlZmluZWQsIGZpbHRlciwgZmxhdHRlbiwgY2h1bmssIHRpbWVzIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBDb21waWxlciBmcm9tICcuLi9jb21waWxlcic7XG5pbXBvcnQgQnJvd3NlckNvbm5lY3Rpb24gZnJvbSAnLi4vYnJvd3Nlci9jb25uZWN0aW9uJztcbmltcG9ydCB7IEdlbmVyYWxFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9ydW50aW1lJztcbmltcG9ydCBicm93c2VyUHJvdmlkZXJQb29sIGZyb20gJy4uL2Jyb3dzZXIvcHJvdmlkZXIvcG9vbCc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL2Vycm9ycy90eXBlcyc7XG5pbXBvcnQgQnJvd3NlclNldCBmcm9tICcuL2Jyb3dzZXItc2V0JztcbmltcG9ydCBUZXN0ZWRBcHAgZnJvbSAnLi90ZXN0ZWQtYXBwJztcbmltcG9ydCBwYXJzZUZpbGVMaXN0IGZyb20gJy4uL3V0aWxzL3BhcnNlLWZpbGUtbGlzdCc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgbWFrZURpciBmcm9tICdtYWtlLWRpcic7XG5pbXBvcnQgcmVzb2x2ZVBhdGhSZWxhdGl2ZWx5Q3dkIGZyb20gJy4uL3V0aWxzL3Jlc29sdmUtcGF0aC1yZWxhdGl2ZWx5LWN3ZCc7XG5pbXBvcnQgbG9hZENsaWVudFNjcmlwdHMgZnJvbSAnLi4vY3VzdG9tLWNsaWVudC1zY3JpcHRzL2xvYWQnO1xuaW1wb3J0IHsgc2V0VW5pcXVlVXJscyB9IGZyb20gJy4uL2N1c3RvbS1jbGllbnQtc2NyaXB0cy91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvb3RzdHJhcHBlciB7XG4gICAgY29uc3RydWN0b3IgKGJyb3dzZXJDb25uZWN0aW9uR2F0ZXdheSkge1xuICAgICAgICB0aGlzLmJyb3dzZXJDb25uZWN0aW9uR2F0ZXdheSA9IGJyb3dzZXJDb25uZWN0aW9uR2F0ZXdheTtcbiAgICAgICAgdGhpcy5jb25jdXJyZW5jeSAgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZXMgICAgICAgICAgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLmJyb3dzZXJzICAgICAgICAgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLnJlcG9ydGVycyAgICAgICAgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLmZpbHRlciAgICAgICAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuYXBwQ29tbWFuZCAgICAgICAgICAgICAgID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcHBJbml0RGVsYXkgICAgICAgICAgICAgPSBudWxsO1xuICAgICAgICB0aGlzLnRzQ29uZmlnUGF0aCAgICAgICAgICAgICA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xpZW50U2NyaXB0cyAgICAgICAgICAgID0gW107XG4gICAgfVxuXG4gICAgc3RhdGljIF9zcGxpdEJyb3dzZXJJbmZvIChicm93c2VySW5mbykge1xuICAgICAgICBjb25zdCByZW1vdGVzICAgPSBbXTtcbiAgICAgICAgY29uc3QgYXV0b21hdGVkID0gW107XG5cbiAgICAgICAgYnJvd3NlckluZm8uZm9yRWFjaChicm93c2VyID0+IHtcbiAgICAgICAgICAgIGlmIChicm93c2VyIGluc3RhbmNlb2YgQnJvd3NlckNvbm5lY3Rpb24pXG4gICAgICAgICAgICAgICAgcmVtb3Rlcy5wdXNoKGJyb3dzZXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGF1dG9tYXRlZC5wdXNoKGJyb3dzZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4geyByZW1vdGVzLCBhdXRvbWF0ZWQgfTtcbiAgICB9XG5cbiAgICBhc3luYyBfZ2V0QnJvd3NlckluZm8gKCkge1xuICAgICAgICBpZiAoIXRoaXMuYnJvd3NlcnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdlbmVyYWxFcnJvcihSVU5USU1FX0VSUk9SUy5icm93c2VyTm90U2V0KTtcblxuICAgICAgICBjb25zdCBicm93c2VySW5mbyA9IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuYnJvd3NlcnMubWFwKGJyb3dzZXIgPT4gYnJvd3NlclByb3ZpZGVyUG9vbC5nZXRCcm93c2VySW5mbyhicm93c2VyKSkpO1xuXG4gICAgICAgIHJldHVybiBmbGF0dGVuKGJyb3dzZXJJbmZvKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQXV0b21hdGVkQ29ubmVjdGlvbnMgKGJyb3dzZXJJbmZvKSB7XG4gICAgICAgIGlmICghYnJvd3NlckluZm8pXG4gICAgICAgICAgICByZXR1cm4gW107XG5cbiAgICAgICAgcmV0dXJuIGJyb3dzZXJJbmZvXG4gICAgICAgICAgICAubWFwKGJyb3dzZXIgPT4gdGltZXModGhpcy5jb25jdXJyZW5jeSwgKCkgPT4gbmV3IEJyb3dzZXJDb25uZWN0aW9uKHRoaXMuYnJvd3NlckNvbm5lY3Rpb25HYXRld2F5LCBicm93c2VyKSkpO1xuICAgIH1cblxuICAgIGFzeW5jIF9nZXRCcm93c2VyQ29ubmVjdGlvbnMgKGJyb3dzZXJJbmZvKSB7XG4gICAgICAgIGNvbnN0IHsgYXV0b21hdGVkLCByZW1vdGVzIH0gPSBCb290c3RyYXBwZXIuX3NwbGl0QnJvd3NlckluZm8oYnJvd3NlckluZm8pO1xuXG4gICAgICAgIGlmIChyZW1vdGVzICYmIHJlbW90ZXMubGVuZ3RoICUgdGhpcy5jb25jdXJyZW5jeSlcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMuY2Fubm90RGl2aWRlUmVtb3Rlc0NvdW50QnlDb25jdXJyZW5jeSk7XG5cbiAgICAgICAgbGV0IGJyb3dzZXJDb25uZWN0aW9ucyA9IHRoaXMuX2NyZWF0ZUF1dG9tYXRlZENvbm5lY3Rpb25zKGF1dG9tYXRlZCk7XG5cbiAgICAgICAgYnJvd3NlckNvbm5lY3Rpb25zID0gYnJvd3NlckNvbm5lY3Rpb25zLmNvbmNhdChjaHVuayhyZW1vdGVzLCB0aGlzLmNvbmN1cnJlbmN5KSk7XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IEJyb3dzZXJTZXQuZnJvbShicm93c2VyQ29ubmVjdGlvbnMpO1xuICAgIH1cblxuICAgIGFzeW5jIF9nZXRUZXN0cyAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2VzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMudGVzdFNvdXJjZXNOb3RTZXQpO1xuXG4gICAgICAgIGNvbnN0IHsgcGFyc2VkRmlsZUxpc3QsIGNvbXBpbGVyT3B0aW9ucyB9ID0gYXdhaXQgdGhpcy5fZ2V0Q29tcGlsZXJBcmd1bWVudHMoKTtcblxuICAgICAgICBjb25zdCBjb21waWxlciA9IG5ldyBDb21waWxlcihwYXJzZWRGaWxlTGlzdCwgY29tcGlsZXJPcHRpb25zKTtcbiAgICAgICAgbGV0IHRlc3RzICAgICAgPSBhd2FpdCBjb21waWxlci5nZXRUZXN0cygpO1xuXG4gICAgICAgIGNvbnN0IHRlc3RzV2l0aE9ubHlGbGFnID0gdGVzdHMuZmlsdGVyKHRlc3QgPT4gdGVzdC5vbmx5KTtcblxuICAgICAgICBpZiAodGVzdHNXaXRoT25seUZsYWcubGVuZ3RoKVxuICAgICAgICAgICAgdGVzdHMgPSB0ZXN0c1dpdGhPbmx5RmxhZztcblxuICAgICAgICBpZiAodGhpcy5maWx0ZXIpXG4gICAgICAgICAgICB0ZXN0cyA9IHRlc3RzLmZpbHRlcih0ZXN0ID0+IHRoaXMuZmlsdGVyKHRlc3QubmFtZSwgdGVzdC5maXh0dXJlLm5hbWUsIHRlc3QuZml4dHVyZS5wYXRoLCB0ZXN0Lm1ldGEsIHRlc3QuZml4dHVyZS5tZXRhKSk7XG5cbiAgICAgICAgaWYgKCF0ZXN0cy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLm5vVGVzdHNUb1J1bik7XG5cbiAgICAgICAgcmV0dXJuIHRlc3RzO1xuICAgIH1cblxuICAgIGFzeW5jIF9nZXRDb21waWxlckFyZ3VtZW50cyAoKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEZpbGVMaXN0ID0gYXdhaXQgcGFyc2VGaWxlTGlzdCh0aGlzLnNvdXJjZXMsIHByb2Nlc3MuY3dkKCkpO1xuXG4gICAgICAgIGNvbnN0IGNvbXBpbGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHR5cGVTY3JpcHRPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgdHNDb25maWdQYXRoOiB0aGlzLnRzQ29uZmlnUGF0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7IHBhcnNlZEZpbGVMaXN0LCBjb21waWxlck9wdGlvbnMgfTtcbiAgICB9XG5cbiAgICBhc3luYyBfZW5zdXJlT3V0U3RyZWFtIChvdXRTdHJlYW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvdXRTdHJlYW0gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIG91dFN0cmVhbTtcblxuICAgICAgICBjb25zdCBmdWxsUmVwb3J0ZXJPdXRwdXRQYXRoID0gcmVzb2x2ZVBhdGhSZWxhdGl2ZWx5Q3dkKG91dFN0cmVhbSk7XG5cbiAgICAgICAgYXdhaXQgbWFrZURpcihwYXRoLmRpcm5hbWUoZnVsbFJlcG9ydGVyT3V0cHV0UGF0aCkpO1xuXG4gICAgICAgIHJldHVybiBmcy5jcmVhdGVXcml0ZVN0cmVhbShmdWxsUmVwb3J0ZXJPdXRwdXRQYXRoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2FkZERlZmF1bHRSZXBvcnRlciAocmVwb3J0ZXJzKSB7XG4gICAgICAgIHJlcG9ydGVycy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6ICdzcGVjJyxcbiAgICAgICAgICAgIGZpbGU6IHByb2Nlc3Muc3Rkb3V0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIF9nZXRSZXBvcnRlclBsdWdpbnMgKCkge1xuICAgICAgICBjb25zdCBzdGRvdXRSZXBvcnRlcnMgPSBmaWx0ZXIodGhpcy5yZXBvcnRlcnMsIHIgPT4gaXNVbmRlZmluZWQoci5vdXRwdXQpIHx8IHIub3V0cHV0ID09PSBwcm9jZXNzLnN0ZG91dCk7XG5cbiAgICAgICAgaWYgKHN0ZG91dFJlcG9ydGVycy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdlbmVyYWxFcnJvcihSVU5USU1FX0VSUk9SUy5tdWx0aXBsZVN0ZG91dFJlcG9ydGVycywgc3Rkb3V0UmVwb3J0ZXJzLm1hcChyID0+IHIubmFtZSkuam9pbignLCAnKSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnJlcG9ydGVycy5sZW5ndGgpXG4gICAgICAgICAgICBCb290c3RyYXBwZXIuX2FkZERlZmF1bHRSZXBvcnRlcih0aGlzLnJlcG9ydGVycyk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMucmVwb3J0ZXJzLm1hcChhc3luYyAoeyBuYW1lLCBvdXRwdXQgfSkgPT4ge1xuICAgICAgICAgICAgbGV0IHBsdWdpbkZhY3RvcnkgPSBuYW1lO1xuXG4gICAgICAgICAgICBjb25zdCBvdXRTdHJlYW0gPSBhd2FpdCB0aGlzLl9lbnN1cmVPdXRTdHJlYW0ob3V0cHV0KTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW5GYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luRmFjdG9yeSA9IHJlcXVpcmUoJ3Rlc3RjYWZlLXJlcG9ydGVyLScgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRSZXBvcnRlckZvckFsaWFzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGx1Z2luOiBwbHVnaW5GYWN0b3J5KCksXG4gICAgICAgICAgICAgICAgb3V0U3RyZWFtXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgX3N0YXJ0VGVzdGVkQXBwICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBwQ29tbWFuZCkge1xuICAgICAgICAgICAgY29uc3QgdGVzdGVkQXBwID0gbmV3IFRlc3RlZEFwcCgpO1xuXG4gICAgICAgICAgICBhd2FpdCB0ZXN0ZWRBcHAuc3RhcnQodGhpcy5hcHBDb21tYW5kLCB0aGlzLmFwcEluaXREZWxheSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0ZXN0ZWRBcHA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBhc3luYyBfY2FuVXNlUGFyYWxsZWxCb290c3RyYXBwaW5nIChicm93c2VySW5mbykge1xuICAgICAgICBjb25zdCBpc0xvY2FsUHJvbWlzZXMgPSBicm93c2VySW5mby5tYXAoYnJvd3NlciA9PiBicm93c2VyLnByb3ZpZGVyLmlzTG9jYWxCcm93c2VyKG51bGwsIGJyb3dzZXJJbmZvLmJyb3dzZXJOYW1lKSk7XG4gICAgICAgIGNvbnN0IGlzTG9jYWxCcm93c2VycyA9IGF3YWl0IFByb21pc2UuYWxsKGlzTG9jYWxQcm9taXNlcyk7XG5cbiAgICAgICAgcmV0dXJuIGlzTG9jYWxCcm93c2Vycy5ldmVyeShyZXN1bHQgPT4gcmVzdWx0KTtcbiAgICB9XG5cbiAgICBhc3luYyBfYm9vdHN0cmFwU2VxdWVuY2UgKGJyb3dzZXJJbmZvLCBjb21tb25DbGllbnRTY3JpcHRzKSB7XG4gICAgICAgIGNvbnN0IHRlc3RzICAgICAgID0gYXdhaXQgdGhpcy5fZ2V0VGVzdHMoKTtcbiAgICAgICAgY29uc3QgdGVzdGVkQXBwICAgPSBhd2FpdCB0aGlzLl9zdGFydFRlc3RlZEFwcCgpO1xuICAgICAgICBjb25zdCBicm93c2VyU2V0ICA9IGF3YWl0IHRoaXMuX2dldEJyb3dzZXJDb25uZWN0aW9ucyhicm93c2VySW5mbyk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fYWRkQ29tbW9uQ2xpZW50U2NyaXB0cyh0ZXN0cywgY29tbW9uQ2xpZW50U2NyaXB0cyk7XG5cbiAgICAgICAgcmV0dXJuIHsgdGVzdHMsIHRlc3RlZEFwcCwgYnJvd3NlclNldCB9O1xuICAgIH1cblxuICAgIF93cmFwQm9vdHN0cmFwcGluZ1Byb21pc2UgKHByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiAoeyBlcnJvcjogbnVsbCwgcmVzdWx0IH0pKVxuICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+ICh7IHJlc3VsdDogbnVsbCwgZXJyb3IgfSkpO1xuICAgIH1cblxuICAgIGFzeW5jIF9oYW5kbGVCb290c3RyYXBwaW5nRXJyb3IgKFticm93c2VyU2V0U3RhdHVzLCB0ZXN0c1N0YXR1cywgdGVzdGVkQXBwU3RhdHVzXSkge1xuICAgICAgICBpZiAoIWJyb3dzZXJTZXRTdGF0dXMuZXJyb3IpXG4gICAgICAgICAgICBhd2FpdCBicm93c2VyU2V0U3RhdHVzLnJlc3VsdC5kaXNwb3NlKCk7XG5cbiAgICAgICAgaWYgKCF0ZXN0ZWRBcHBTdGF0dXMuZXJyb3IgJiYgdGVzdGVkQXBwU3RhdHVzLnJlc3VsdClcbiAgICAgICAgICAgIGF3YWl0IHRlc3RlZEFwcFN0YXR1cy5yZXN1bHQua2lsbCgpO1xuXG4gICAgICAgIGlmICh0ZXN0c1N0YXR1cy5lcnJvcilcbiAgICAgICAgICAgIHRocm93IHRlc3RzU3RhdHVzLmVycm9yO1xuICAgICAgICBlbHNlIGlmICh0ZXN0ZWRBcHBTdGF0dXMuZXJyb3IpXG4gICAgICAgICAgICB0aHJvdyB0ZXN0ZWRBcHBTdGF0dXMuZXJyb3I7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IGJyb3dzZXJTZXRTdGF0dXMuZXJyb3I7XG4gICAgfVxuXG4gICAgYXN5bmMgX2Jvb3RzdHJhcFBhcmFsbGVsIChicm93c2VySW5mbywgY29tbW9uQ2xpZW50U2NyaXB0cykge1xuICAgICAgICBsZXQgYm9vdHN0cmFwcGluZ1Byb21pc2VzID0gW1xuICAgICAgICAgICAgdGhpcy5fZ2V0QnJvd3NlckNvbm5lY3Rpb25zKGJyb3dzZXJJbmZvKSxcbiAgICAgICAgICAgIHRoaXMuX2dldFRlc3RzKCksXG4gICAgICAgICAgICB0aGlzLl9zdGFydFRlc3RlZEFwcCgpXG4gICAgICAgIF07XG5cbiAgICAgICAgYm9vdHN0cmFwcGluZ1Byb21pc2VzID0gYm9vdHN0cmFwcGluZ1Byb21pc2VzLm1hcChwcm9taXNlID0+IHRoaXMuX3dyYXBCb290c3RyYXBwaW5nUHJvbWlzZShwcm9taXNlKSk7XG5cbiAgICAgICAgY29uc3QgYm9vdHN0cmFwcGluZ1N0YXR1c2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoYm9vdHN0cmFwcGluZ1Byb21pc2VzKTtcblxuICAgICAgICBpZiAoYm9vdHN0cmFwcGluZ1N0YXR1c2VzLnNvbWUoc3RhdHVzID0+IHN0YXR1cy5lcnJvcikpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9oYW5kbGVCb290c3RyYXBwaW5nRXJyb3IoYm9vdHN0cmFwcGluZ1N0YXR1c2VzKTtcblxuICAgICAgICBjb25zdCBbYnJvd3NlclNldCwgdGVzdHMsIHRlc3RlZEFwcF0gPSBib290c3RyYXBwaW5nU3RhdHVzZXMubWFwKHN0YXR1cyA9PiBzdGF0dXMucmVzdWx0KTtcblxuICAgICAgICBhd2FpdCB0aGlzLl9hZGRDb21tb25DbGllbnRTY3JpcHRzKHRlc3RzLCBjb21tb25DbGllbnRTY3JpcHRzKTtcblxuICAgICAgICByZXR1cm4geyBicm93c2VyU2V0LCB0ZXN0cywgdGVzdGVkQXBwIH07XG4gICAgfVxuXG4gICAgYXN5bmMgX2FkZENvbW1vbkNsaWVudFNjcmlwdHMgKHRlc3RzLCBjbGllbnRTY3JpcHRzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0ZXN0cy5tYXAoYXN5bmMgdGVzdCA9PiB7XG4gICAgICAgICAgICBpZiAodGVzdC5pc0xlZ2FjeSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGxldCBsb2FkZWRUZXN0Q2xpZW50U2NyaXB0cyA9IGF3YWl0IGxvYWRDbGllbnRTY3JpcHRzKHRlc3QuY2xpZW50U2NyaXB0cywgcGF0aC5kaXJuYW1lKHRlc3QudGVzdEZpbGUuZmlsZW5hbWUpKTtcblxuICAgICAgICAgICAgbG9hZGVkVGVzdENsaWVudFNjcmlwdHMgPSBjbGllbnRTY3JpcHRzLmNvbmNhdChsb2FkZWRUZXN0Q2xpZW50U2NyaXB0cyk7XG5cbiAgICAgICAgICAgIHRlc3QuY2xpZW50U2NyaXB0cyA9IHNldFVuaXF1ZVVybHMobG9hZGVkVGVzdENsaWVudFNjcmlwdHMpO1xuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLy8gQVBJXG4gICAgYXN5bmMgY3JlYXRlUnVubmFibGVDb25maWd1cmF0aW9uICgpIHtcbiAgICAgICAgY29uc3QgcmVwb3J0ZXJQbHVnaW5zICAgICA9IGF3YWl0IHRoaXMuX2dldFJlcG9ydGVyUGx1Z2lucygpO1xuICAgICAgICBjb25zdCBjb21tb25DbGllbnRTY3JpcHRzID0gYXdhaXQgbG9hZENsaWVudFNjcmlwdHModGhpcy5jbGllbnRTY3JpcHRzKTtcblxuICAgICAgICAvLyBOT1RFOiBJZiBhIHVzZXIgZm9yZ290IHRvIHNwZWNpZnkgYSBicm93c2VyLCBidXQgaGFzIHNwZWNpZmllZCBhIHBhdGggdG8gdGVzdHMsIHRoZSBzcGVjaWZpZWQgcGF0aCB3aWxsIGJlXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgYXMgdGhlIGJyb3dzZXIgYXJndW1lbnQsIGFuZCB0aGUgdGVzdHMgcGF0aCBhcmd1bWVudCB3aWxsIGhhdmUgdGhlIHByZWRlZmluZWQgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgLy8gSXQncyB2ZXJ5IGFtYmlndW91cyBmb3IgdGhlIHVzZXIsIHdobyBtaWdodCBiZSBjb25mdXNlZCBieSBjb21waWxhdGlvbiBlcnJvcnMgZnJvbSBhbiB1bmV4cGVjdGVkIHRlc3QuXG4gICAgICAgIC8vIFNvLCB3ZSBuZWVkIHRvIHJldHJpZXZlIHRoZSBicm93c2VyIGFsaWFzZXMgYW5kIHBhdGhzIGJlZm9yZSB0ZXN0cyBjb21waWxhdGlvbi5cbiAgICAgICAgY29uc3QgYnJvd3NlckluZm8gPSBhd2FpdCB0aGlzLl9nZXRCcm93c2VySW5mbygpO1xuXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLl9jYW5Vc2VQYXJhbGxlbEJvb3RzdHJhcHBpbmcoYnJvd3NlckluZm8pKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmVwb3J0ZXJQbHVnaW5zLCAuLi5hd2FpdCB0aGlzLl9ib290c3RyYXBQYXJhbGxlbChicm93c2VySW5mbywgY29tbW9uQ2xpZW50U2NyaXB0cykgfTtcblxuICAgICAgICByZXR1cm4geyByZXBvcnRlclBsdWdpbnMsIC4uLmF3YWl0IHRoaXMuX2Jvb3RzdHJhcFNlcXVlbmNlKGJyb3dzZXJJbmZvLCBjb21tb25DbGllbnRTY3JpcHRzKSB9O1xuICAgIH1cbn1cbiJdfQ==