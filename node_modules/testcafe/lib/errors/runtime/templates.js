"use strict";
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
exports.default = {
    [types_1.RUNTIME_ERRORS.cannotCreateMultipleLiveModeRunners]: 'Cannot create multiple live mode runners.',
    [types_1.RUNTIME_ERRORS.cannotRunLiveModeRunnerMultipleTimes]: 'Cannot run a live mode runner multiple times.',
    [types_1.RUNTIME_ERRORS.browserDisconnected]: 'The {userAgent} browser disconnected. This problem may appear when a browser hangs or is closed, or due to network issues.',
    [types_1.RUNTIME_ERRORS.cannotRunAgainstDisconnectedBrowsers]: 'The following browsers disconnected: {userAgents}. Tests will not be run.',
    [types_1.RUNTIME_ERRORS.cannotEstablishBrowserConnection]: 'Unable to establish one or more of the specified browser connections. This can be caused by network issues or remote device failure.',
    [types_1.RUNTIME_ERRORS.cannotFindBrowser]: 'Unable to find the browser. "{browser}" is not a browser alias or path to an executable file.',
    [types_1.RUNTIME_ERRORS.browserProviderNotFound]: 'The specified "{providerName}" browser provider was not found.',
    [types_1.RUNTIME_ERRORS.browserNotSet]: 'No browser selected to test against.',
    [types_1.RUNTIME_ERRORS.testSourcesNotSet]: 'No test file specified.',
    [types_1.RUNTIME_ERRORS.noTestsToRun]: 'No tests to run. Either the test files contain no tests or the filter function is too restrictive.',
    [types_1.RUNTIME_ERRORS.cannotFindReporterForAlias]: 'The provided "{name}" reporter does not exist. Check that you have specified the report format correctly.',
    [types_1.RUNTIME_ERRORS.multipleStdoutReporters]: 'Multiple reporters attempting to write to stdout: "{reporters}". Only one reporter can write to stdout.',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidRegExp]: 'The "{optionName}" option value is not a valid regular expression.',
    [types_1.RUNTIME_ERRORS.optionValueIsNotValidKeyValue]: 'The "{optionName}" option value is not a valid key-value pair.',
    [types_1.RUNTIME_ERRORS.invalidSpeedValue]: 'Speed should be a number between 0.01 and 1.',
    [types_1.RUNTIME_ERRORS.invalidConcurrencyFactor]: 'The concurrency factor should be an integer greater or equal to 1.',
    [types_1.RUNTIME_ERRORS.cannotDivideRemotesCountByConcurrency]: 'The number of remote browsers should be divisible by the factor of concurrency.',
    [types_1.RUNTIME_ERRORS.portsOptionRequiresTwoNumbers]: 'The "--ports" option requires two numbers to be specified.',
    [types_1.RUNTIME_ERRORS.portIsNotFree]: 'The specified {portNum} port is already in use by another program.',
    [types_1.RUNTIME_ERRORS.invalidHostname]: 'The specified "{hostname}" hostname cannot be resolved to the current machine.',
    [types_1.RUNTIME_ERRORS.cannotFindSpecifiedTestSource]: 'Cannot find a test source file at "{path}".',
    [types_1.RUNTIME_ERRORS.clientFunctionCodeIsNotAFunction]: '{#instantiationCallsiteName} code is expected to be specified as a function, but {type} was passed.',
    [types_1.RUNTIME_ERRORS.selectorInitializedWithWrongType]: '{#instantiationCallsiteName} is expected to be initialized with a function, CSS selector string, another Selector, node snapshot or a Promise returned by a Selector, but {type} was passed.',
    [types_1.RUNTIME_ERRORS.clientFunctionCannotResolveTestRun]: "{#instantiationCallsiteName} cannot implicitly resolve the test run in context of which it should be executed. If you need to call {#instantiationCallsiteName} from the Node.js API callback, pass the test controller manually via {#instantiationCallsiteName}'s `.with({ boundTestRun: t })` method first. Note that you cannot execute {#instantiationCallsiteName} outside the test code.",
    [types_1.RUNTIME_ERRORS.regeneratorInClientFunctionCode]: `{#instantiationCallsiteName} code, arguments or dependencies cannot contain generators or "async/await" syntax (use Promises instead).`,
    [types_1.RUNTIME_ERRORS.invalidClientFunctionTestRunBinding]: 'The "boundTestRun" option value is expected to be a test controller.',
    [types_1.RUNTIME_ERRORS.invalidValueType]: '{smthg} is expected to be a {type}, but it was {actual}.',
    [types_1.RUNTIME_ERRORS.unsupportedUrlProtocol]: 'The specified "{url}" test page URL uses an unsupported {protocol}:// protocol. Only relative URLs or absolute URLs with http://, https:// and file:// protocols are supported.',
    [types_1.RUNTIME_ERRORS.testControllerProxyCannotResolveTestRun]: `Cannot implicitly resolve the test run in the context of which the test controller action should be executed. Use test function's 't' argument instead.`,
    [types_1.RUNTIME_ERRORS.timeLimitedPromiseTimeoutExpired]: 'Timeout expired for a time limited promise',
    [types_1.RUNTIME_ERRORS.cannotUseScreenshotPathPatternWithoutBaseScreenshotPathSpecified]: 'Unable to set the screenshot path pattern when screenshots are disabled. Specify the base path where screenshots are stored to enable them.',
    [types_1.RUNTIME_ERRORS.cannotSetVideoOptionsWithoutBaseVideoPathSpecified]: 'Unable to set video or encoding options when video recording is disabled. Specify the base path where video files are stored to enable recording.',
    [types_1.RUNTIME_ERRORS.multipleAPIMethodCallForbidden]: 'You cannot call the "{methodName}" method more than once. Pass an array of parameters to this method instead.',
    [types_1.RUNTIME_ERRORS.invalidReporterOutput]: "Specify a file name or a writable stream as the reporter's output target.",
    [types_1.RUNTIME_ERRORS.cannotReadSSLCertFile]: 'Unable to read the "{path}" file, specified by the "{option}" ssl option. Error details:\n' +
        '\n' +
        '{err}',
    [types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError]: 'Cannot prepare tests due to an error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.cannotParseRawFile]: 'Cannot parse a test source file in the raw format at "{path}" due to an error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.testedAppFailedWithError]: 'Tested app failed with an error:\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.unableToOpenBrowser]: 'Was unable to open the browser "{alias}" due to error.\n' +
        '\n' +
        '{errMessage}',
    [types_1.RUNTIME_ERRORS.requestHookConfigureAPIError]: 'There was an error while configuring the request hook:\n' +
        '\n' +
        '{requestHookName}: {errMsg}',
    [types_1.RUNTIME_ERRORS.forbiddenCharatersInScreenshotPath]: 'There are forbidden characters in the "{screenshotPath}" {screenshotPathType}:\n' +
        ' {forbiddenCharsDescription}',
    [types_1.RUNTIME_ERRORS.cannotFindFFMPEG]: 'Unable to locate the FFmpeg executable required to record videos. Do one of the following:\n' +
        '\n' +
        '* add the FFmpeg installation directory to the PATH environment variable,\n' +
        '* specify the path to the FFmpeg executable in the FFMPEG_PATH environment variable or the ffmpegPath video option,\n' +
        '* install the @ffmpeg-installer/ffmpeg package from npm.',
    [types_1.RUNTIME_ERRORS.cannotFindTypescriptConfigurationFile]: 'Unable to find the TypeScript configuration file in "{filePath}"',
    [types_1.RUNTIME_ERRORS.clientScriptInitializerIsNotSpecified]: 'Specify the JavaScript file path, module name or script content to inject a client script.',
    [types_1.RUNTIME_ERRORS.clientScriptBasePathIsNotSpecified]: 'Specify the base path for the client script file.',
    [types_1.RUNTIME_ERRORS.clientScriptInitializerMultipleContentSources]: 'You cannot combine the file path, module name and script content when you specify a client script to inject.',
    [types_1.RUNTIME_ERRORS.cannotLoadClientScriptFromPath]: 'Cannot load a client script from {path}',
    [types_1.RUNTIME_ERRORS.clientScriptModuleEntryPointPathCalculationError]: 'An error occurred when trying to locate the injected client script module:\n\n{errorMessage}.'
};
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vycm9ycy9ydW50aW1lL3RlbXBsYXRlcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRSwrQ0FBK0M7QUFDL0MsZ0VBQWdFOztBQUVoRSxvQ0FBMEM7QUFFMUMsa0JBQWU7SUFDWCxDQUFDLHNCQUFjLENBQUMsbUNBQW1DLENBQUMsRUFBK0IsMkNBQTJDO0lBQzlILENBQUMsc0JBQWMsQ0FBQyxvQ0FBb0MsQ0FBQyxFQUE4QiwrQ0FBK0M7SUFDbEksQ0FBQyxzQkFBYyxDQUFDLG1CQUFtQixDQUFDLEVBQStDLDRIQUE0SDtJQUMvTSxDQUFDLHNCQUFjLENBQUMsb0NBQW9DLENBQUMsRUFBOEIsMkVBQTJFO0lBQzlKLENBQUMsc0JBQWMsQ0FBQyxnQ0FBZ0MsQ0FBQyxFQUFrQyxzSUFBc0k7SUFDek4sQ0FBQyxzQkFBYyxDQUFDLGlCQUFpQixDQUFDLEVBQWlELCtGQUErRjtJQUNsTCxDQUFDLHNCQUFjLENBQUMsdUJBQXVCLENBQUMsRUFBMkMsZ0VBQWdFO0lBQ25KLENBQUMsc0JBQWMsQ0FBQyxhQUFhLENBQUMsRUFBcUQsc0NBQXNDO0lBQ3pILENBQUMsc0JBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFpRCx5QkFBeUI7SUFDNUcsQ0FBQyxzQkFBYyxDQUFDLFlBQVksQ0FBQyxFQUFzRCxvR0FBb0c7SUFDdkwsQ0FBQyxzQkFBYyxDQUFDLDBCQUEwQixDQUFDLEVBQXdDLDJHQUEyRztJQUM5TCxDQUFDLHNCQUFjLENBQUMsdUJBQXVCLENBQUMsRUFBMkMseUdBQXlHO0lBQzVMLENBQUMsc0JBQWMsQ0FBQywyQkFBMkIsQ0FBQyxFQUF1QyxvRUFBb0U7SUFDdkosQ0FBQyxzQkFBYyxDQUFDLDZCQUE2QixDQUFDLEVBQXFDLGdFQUFnRTtJQUNuSixDQUFDLHNCQUFjLENBQUMsaUJBQWlCLENBQUMsRUFBaUQs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LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBXQVJOSU5HOiB0aGlzIGZpbGUgaXMgdXNlZCBieSBib3RoIHRoZSBjbGllbnQgYW5kIHRoZSBzZXJ2ZXIuXG4vLyBEbyBub3QgdXNlIGFueSBicm93c2VyIG9yIG5vZGUtc3BlY2lmaWMgQVBJIVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RDcmVhdGVNdWx0aXBsZUxpdmVNb2RlUnVubmVyc106ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Nhbm5vdCBjcmVhdGUgbXVsdGlwbGUgbGl2ZSBtb2RlIHJ1bm5lcnMuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90UnVuTGl2ZU1vZGVSdW5uZXJNdWx0aXBsZVRpbWVzXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgcnVuIGEgbGl2ZSBtb2RlIHJ1bm5lciBtdWx0aXBsZSB0aW1lcy4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5icm93c2VyRGlzY29ubmVjdGVkXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSB7dXNlckFnZW50fSBicm93c2VyIGRpc2Nvbm5lY3RlZC4gVGhpcyBwcm9ibGVtIG1heSBhcHBlYXIgd2hlbiBhIGJyb3dzZXIgaGFuZ3Mgb3IgaXMgY2xvc2VkLCBvciBkdWUgdG8gbmV0d29yayBpc3N1ZXMuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90UnVuQWdhaW5zdERpc2Nvbm5lY3RlZEJyb3dzZXJzXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgZm9sbG93aW5nIGJyb3dzZXJzIGRpc2Nvbm5lY3RlZDoge3VzZXJBZ2VudHN9LiBUZXN0cyB3aWxsIG5vdCBiZSBydW4uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90RXN0YWJsaXNoQnJvd3NlckNvbm5lY3Rpb25dOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVbmFibGUgdG8gZXN0YWJsaXNoIG9uZSBvciBtb3JlIG9mIHRoZSBzcGVjaWZpZWQgYnJvd3NlciBjb25uZWN0aW9ucy4gVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IG5ldHdvcmsgaXNzdWVzIG9yIHJlbW90ZSBkZXZpY2UgZmFpbHVyZS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kQnJvd3Nlcl06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VuYWJsZSB0byBmaW5kIHRoZSBicm93c2VyLiBcInticm93c2VyfVwiIGlzIG5vdCBhIGJyb3dzZXIgYWxpYXMgb3IgcGF0aCB0byBhbiBleGVjdXRhYmxlIGZpbGUuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuYnJvd3NlclByb3ZpZGVyTm90Rm91bmRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIFwie3Byb3ZpZGVyTmFtZX1cIiBicm93c2VyIHByb3ZpZGVyIHdhcyBub3QgZm91bmQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuYnJvd3Nlck5vdFNldF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdObyBicm93c2VyIHNlbGVjdGVkIHRvIHRlc3QgYWdhaW5zdC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy50ZXN0U291cmNlc05vdFNldF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ05vIHRlc3QgZmlsZSBzcGVjaWZpZWQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMubm9UZXN0c1RvUnVuXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdObyB0ZXN0cyB0byBydW4uIEVpdGhlciB0aGUgdGVzdCBmaWxlcyBjb250YWluIG5vIHRlc3RzIG9yIHRoZSBmaWx0ZXIgZnVuY3Rpb24gaXMgdG9vIHJlc3RyaWN0aXZlLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRSZXBvcnRlckZvckFsaWFzXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3ZpZGVkIFwie25hbWV9XCIgcmVwb3J0ZXIgZG9lcyBub3QgZXhpc3QuIENoZWNrIHRoYXQgeW91IGhhdmUgc3BlY2lmaWVkIHRoZSByZXBvcnQgZm9ybWF0IGNvcnJlY3RseS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5tdWx0aXBsZVN0ZG91dFJlcG9ydGVyc106ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ011bHRpcGxlIHJlcG9ydGVycyBhdHRlbXB0aW5nIHRvIHdyaXRlIHRvIHN0ZG91dDogXCJ7cmVwb3J0ZXJzfVwiLiBPbmx5IG9uZSByZXBvcnRlciBjYW4gd3JpdGUgdG8gc3Rkb3V0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLm9wdGlvblZhbHVlSXNOb3RWYWxpZFJlZ0V4cF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwie29wdGlvbk5hbWV9XCIgb3B0aW9uIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbi4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5vcHRpb25WYWx1ZUlzTm90VmFsaWRLZXlWYWx1ZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcIntvcHRpb25OYW1lfVwiIG9wdGlvbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBrZXktdmFsdWUgcGFpci4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5pbnZhbGlkU3BlZWRWYWx1ZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1NwZWVkIHNob3VsZCBiZSBhIG51bWJlciBiZXR3ZWVuIDAuMDEgYW5kIDEuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZENvbmN1cnJlbmN5RmFjdG9yXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgY29uY3VycmVuY3kgZmFjdG9yIHNob3VsZCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3REaXZpZGVSZW1vdGVzQ291bnRCeUNvbmN1cnJlbmN5XTogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBudW1iZXIgb2YgcmVtb3RlIGJyb3dzZXJzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgdGhlIGZhY3RvciBvZiBjb25jdXJyZW5jeS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5wb3J0c09wdGlvblJlcXVpcmVzVHdvTnVtYmVyc106ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcIi0tcG9ydHNcIiBvcHRpb24gcmVxdWlyZXMgdHdvIG51bWJlcnMgdG8gYmUgc3BlY2lmaWVkLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnBvcnRJc05vdEZyZWVdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCB7cG9ydE51bX0gcG9ydCBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIHByb2dyYW0uJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZEhvc3RuYW1lXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIFwie2hvc3RuYW1lfVwiIGhvc3RuYW1lIGNhbm5vdCBiZSByZXNvbHZlZCB0byB0aGUgY3VycmVudCBtYWNoaW5lLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRTcGVjaWZpZWRUZXN0U291cmNlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IGZpbmQgYSB0ZXN0IHNvdXJjZSBmaWxlIGF0IFwie3BhdGh9XCIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50RnVuY3Rpb25Db2RlSXNOb3RBRnVuY3Rpb25dOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNvZGUgaXMgZXhwZWN0ZWQgdG8gYmUgc3BlY2lmaWVkIGFzIGEgZnVuY3Rpb24sIGJ1dCB7dHlwZX0gd2FzIHBhc3NlZC4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5zZWxlY3RvckluaXRpYWxpemVkV2l0aFdyb25nVHlwZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3sjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gaXMgZXhwZWN0ZWQgdG8gYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGZ1bmN0aW9uLCBDU1Mgc2VsZWN0b3Igc3RyaW5nLCBhbm90aGVyIFNlbGVjdG9yLCBub2RlIHNuYXBzaG90IG9yIGEgUHJvbWlzZSByZXR1cm5lZCBieSBhIFNlbGVjdG9yLCBidXQge3R5cGV9IHdhcyBwYXNzZWQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50RnVuY3Rpb25DYW5ub3RSZXNvbHZlVGVzdFJ1bl06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBjYW5ub3QgaW1wbGljaXRseSByZXNvbHZlIHRoZSB0ZXN0IHJ1biBpbiBjb250ZXh0IG9mIHdoaWNoIGl0IHNob3VsZCBiZSBleGVjdXRlZC4gSWYgeW91IG5lZWQgdG8gY2FsbCB7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGZyb20gdGhlIE5vZGUuanMgQVBJIGNhbGxiYWNrLCBwYXNzIHRoZSB0ZXN0IGNvbnRyb2xsZXIgbWFudWFsbHkgdmlhIHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0ncyBgLndpdGgoeyBib3VuZFRlc3RSdW46IHQgfSlgIG1ldGhvZCBmaXJzdC4gTm90ZSB0aGF0IHlvdSBjYW5ub3QgZXhlY3V0ZSB7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IG91dHNpZGUgdGhlIHRlc3QgY29kZS5cIixcbiAgICBbUlVOVElNRV9FUlJPUlMucmVnZW5lcmF0b3JJbkNsaWVudEZ1bmN0aW9uQ29kZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNvZGUsIGFyZ3VtZW50cyBvciBkZXBlbmRlbmNpZXMgY2Fubm90IGNvbnRhaW4gZ2VuZXJhdG9ycyBvciBcImFzeW5jL2F3YWl0XCIgc3ludGF4ICh1c2UgUHJvbWlzZXMgaW5zdGVhZCkuYCxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZENsaWVudEZ1bmN0aW9uVGVzdFJ1bkJpbmRpbmddOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgXCJib3VuZFRlc3RSdW5cIiBvcHRpb24gdmFsdWUgaXMgZXhwZWN0ZWQgdG8gYmUgYSB0ZXN0IGNvbnRyb2xsZXIuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuaW52YWxpZFZhbHVlVHlwZV06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7c210aGd9IGlzIGV4cGVjdGVkIHRvIGJlIGEge3R5cGV9LCBidXQgaXQgd2FzIHthY3R1YWx9LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLnVuc3VwcG9ydGVkVXJsUHJvdG9jb2xdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCBcInt1cmx9XCIgdGVzdCBwYWdlIFVSTCB1c2VzIGFuIHVuc3VwcG9ydGVkIHtwcm90b2NvbH06Ly8gcHJvdG9jb2wuIE9ubHkgcmVsYXRpdmUgVVJMcyBvciBhYnNvbHV0ZSBVUkxzIHdpdGggaHR0cDovLywgaHR0cHM6Ly8gYW5kIGZpbGU6Ly8gcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMudGVzdENvbnRyb2xsZXJQcm94eUNhbm5vdFJlc29sdmVUZXN0UnVuXTogICAgICAgICAgICAgICAgICAgICAgICAgIGBDYW5ub3QgaW1wbGljaXRseSByZXNvbHZlIHRoZSB0ZXN0IHJ1biBpbiB0aGUgY29udGV4dCBvZiB3aGljaCB0aGUgdGVzdCBjb250cm9sbGVyIGFjdGlvbiBzaG91bGQgYmUgZXhlY3V0ZWQuIFVzZSB0ZXN0IGZ1bmN0aW9uJ3MgJ3QnIGFyZ3VtZW50IGluc3RlYWQuYCxcbiAgICBbUlVOVElNRV9FUlJPUlMudGltZUxpbWl0ZWRQcm9taXNlVGltZW91dEV4cGlyZWRdOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaW1lb3V0IGV4cGlyZWQgZm9yIGEgdGltZSBsaW1pdGVkIHByb21pc2UnLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RVc2VTY3JlZW5zaG90UGF0aFBhdHRlcm5XaXRob3V0QmFzZVNjcmVlbnNob3RQYXRoU3BlY2lmaWVkXTogJ1VuYWJsZSB0byBzZXQgdGhlIHNjcmVlbnNob3QgcGF0aCBwYXR0ZXJuIHdoZW4gc2NyZWVuc2hvdHMgYXJlIGRpc2FibGVkLiBTcGVjaWZ5IHRoZSBiYXNlIHBhdGggd2hlcmUgc2NyZWVuc2hvdHMgYXJlIHN0b3JlZCB0byBlbmFibGUgdGhlbS4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RTZXRWaWRlb09wdGlvbnNXaXRob3V0QmFzZVZpZGVvUGF0aFNwZWNpZmllZF06ICAgICAgICAgICAgICAgJ1VuYWJsZSB0byBzZXQgdmlkZW8gb3IgZW5jb2Rpbmcgb3B0aW9ucyB3aGVuIHZpZGVvIHJlY29yZGluZyBpcyBkaXNhYmxlZC4gU3BlY2lmeSB0aGUgYmFzZSBwYXRoIHdoZXJlIHZpZGVvIGZpbGVzIGFyZSBzdG9yZWQgdG8gZW5hYmxlIHJlY29yZGluZy4nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5tdWx0aXBsZUFQSU1ldGhvZENhbGxGb3JiaWRkZW5dOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1lvdSBjYW5ub3QgY2FsbCB0aGUgXCJ7bWV0aG9kTmFtZX1cIiBtZXRob2QgbW9yZSB0aGFuIG9uY2UuIFBhc3MgYW4gYXJyYXkgb2YgcGFyYW1ldGVycyB0byB0aGlzIG1ldGhvZCBpbnN0ZWFkLicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmludmFsaWRSZXBvcnRlck91dHB1dF06ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlNwZWNpZnkgYSBmaWxlIG5hbWUgb3IgYSB3cml0YWJsZSBzdHJlYW0gYXMgdGhlIHJlcG9ydGVyJ3Mgb3V0cHV0IHRhcmdldC5cIixcbiAgICBbUlVOVElNRV9FUlJPUlMuY2Fubm90UmVhZFNTTENlcnRGaWxlXTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVbmFibGUgdG8gcmVhZCB0aGUgXCJ7cGF0aH1cIiBmaWxlLCBzcGVjaWZpZWQgYnkgdGhlIFwie29wdGlvbn1cIiBzc2wgb3B0aW9uLiBFcnJvciBkZXRhaWxzOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tlcnJ9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RQcmVwYXJlVGVzdHNEdWVUb0Vycm9yXTogJ0Nhbm5vdCBwcmVwYXJlIHRlc3RzIGR1ZSB0byBhbiBlcnJvci5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RQYXJzZVJhd0ZpbGVdOiAnQ2Fubm90IHBhcnNlIGEgdGVzdCBzb3VyY2UgZmlsZSBpbiB0aGUgcmF3IGZvcm1hdCBhdCBcIntwYXRofVwiIGR1ZSB0byBhbiBlcnJvci5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3tlcnJNZXNzYWdlfScsXG5cbiAgICBbUlVOVElNRV9FUlJPUlMudGVzdGVkQXBwRmFpbGVkV2l0aEVycm9yXTogJ1Rlc3RlZCBhcHAgZmFpbGVkIHdpdGggYW4gZXJyb3I6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7ZXJyTWVzc2FnZX0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLnVuYWJsZVRvT3BlbkJyb3dzZXJdOiAnV2FzIHVuYWJsZSB0byBvcGVuIHRoZSBicm93c2VyIFwie2FsaWFzfVwiIGR1ZSB0byBlcnJvci5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne2Vyck1lc3NhZ2V9JyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5yZXF1ZXN0SG9va0NvbmZpZ3VyZUFQSUVycm9yXTogJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBjb25maWd1cmluZyB0aGUgcmVxdWVzdCBob29rOlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7cmVxdWVzdEhvb2tOYW1lfToge2Vyck1zZ30nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmZvcmJpZGRlbkNoYXJhdGVyc0luU2NyZWVuc2hvdFBhdGhdOiAnVGhlcmUgYXJlIGZvcmJpZGRlbiBjaGFyYWN0ZXJzIGluIHRoZSBcIntzY3JlZW5zaG90UGF0aH1cIiB7c2NyZWVuc2hvdFBhdGhUeXBlfTpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB7Zm9yYmlkZGVuQ2hhcnNEZXNjcmlwdGlvbn0nLFxuXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRGRk1QRUddOiAnVW5hYmxlIHRvIGxvY2F0ZSB0aGUgRkZtcGVnIGV4ZWN1dGFibGUgcmVxdWlyZWQgdG8gcmVjb3JkIHZpZGVvcy4gRG8gb25lIG9mIHRoZSBmb2xsb3dpbmc6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyogYWRkIHRoZSBGRm1wZWcgaW5zdGFsbGF0aW9uIGRpcmVjdG9yeSB0byB0aGUgUEFUSCBlbnZpcm9ubWVudCB2YXJpYWJsZSxcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyogc3BlY2lmeSB0aGUgcGF0aCB0byB0aGUgRkZtcGVnIGV4ZWN1dGFibGUgaW4gdGhlIEZGTVBFR19QQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHRoZSBmZm1wZWdQYXRoIHZpZGVvIG9wdGlvbixcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyogaW5zdGFsbCB0aGUgQGZmbXBlZy1pbnN0YWxsZXIvZmZtcGVnIHBhY2thZ2UgZnJvbSBucG0uJyxcblxuICAgIFtSVU5USU1FX0VSUk9SUy5jYW5ub3RGaW5kVHlwZXNjcmlwdENvbmZpZ3VyYXRpb25GaWxlXTogICAgICAgICAgICAnVW5hYmxlIHRvIGZpbmQgdGhlIFR5cGVTY3JpcHQgY29uZmlndXJhdGlvbiBmaWxlIGluIFwie2ZpbGVQYXRofVwiJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50U2NyaXB0SW5pdGlhbGl6ZXJJc05vdFNwZWNpZmllZF06ICAgICAgICAgICAgJ1NwZWNpZnkgdGhlIEphdmFTY3JpcHQgZmlsZSBwYXRoLCBtb2R1bGUgbmFtZSBvciBzY3JpcHQgY29udGVudCB0byBpbmplY3QgYSBjbGllbnQgc2NyaXB0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNsaWVudFNjcmlwdEJhc2VQYXRoSXNOb3RTcGVjaWZpZWRdOiAgICAgICAgICAgICAgICdTcGVjaWZ5IHRoZSBiYXNlIHBhdGggZm9yIHRoZSBjbGllbnQgc2NyaXB0IGZpbGUuJyxcbiAgICBbUlVOVElNRV9FUlJPUlMuY2xpZW50U2NyaXB0SW5pdGlhbGl6ZXJNdWx0aXBsZUNvbnRlbnRTb3VyY2VzXTogICAgJ1lvdSBjYW5ub3QgY29tYmluZSB0aGUgZmlsZSBwYXRoLCBtb2R1bGUgbmFtZSBhbmQgc2NyaXB0IGNvbnRlbnQgd2hlbiB5b3Ugc3BlY2lmeSBhIGNsaWVudCBzY3JpcHQgdG8gaW5qZWN0LicsXG4gICAgW1JVTlRJTUVfRVJST1JTLmNhbm5vdExvYWRDbGllbnRTY3JpcHRGcm9tUGF0aF06ICAgICAgICAgICAgICAgICAgICdDYW5ub3QgbG9hZCBhIGNsaWVudCBzY3JpcHQgZnJvbSB7cGF0aH0nLFxuICAgIFtSVU5USU1FX0VSUk9SUy5jbGllbnRTY3JpcHRNb2R1bGVFbnRyeVBvaW50UGF0aENhbGN1bGF0aW9uRXJyb3JdOiAnQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiB0cnlpbmcgdG8gbG9jYXRlIHRoZSBpbmplY3RlZCBjbGllbnQgc2NyaXB0IG1vZHVsZTpcXG5cXG57ZXJyb3JNZXNzYWdlfS4nXG59O1xuIl19