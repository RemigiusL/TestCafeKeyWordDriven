"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const callsite_record_1 = require("callsite-record");
const templates_1 = __importDefault(require("./templates"));
const create_stack_filter_1 = __importDefault(require("../create-stack-filter"));
const get_callsite_1 = require("../get-callsite");
const render_template_1 = __importDefault(require("../../utils/render-template"));
const types_1 = require("../types");
const ERROR_SEPARATOR = '\n\n';
class ProcessTemplateInstruction {
    constructor(processFn) {
        this.processFn = processFn;
    }
}
// Errors
class GeneralError extends Error {
    constructor(...args) {
        const code = args.shift();
        const template = templates_1.default[code];
        super(render_template_1.default(template, ...args));
        Object.assign(this, { code, data: args });
        Error.captureStackTrace(this, GeneralError);
    }
}
exports.GeneralError = GeneralError;
class TestCompilationError extends Error {
    constructor(originalError) {
        const template = templates_1.default[types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError];
        const errorMessage = originalError.toString();
        super(render_template_1.default(template, errorMessage));
        Object.assign(this, {
            code: types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError,
            data: [errorMessage]
        });
        // NOTE: stack includes message as well.
        this.stack = render_template_1.default(template, originalError.stack);
    }
}
exports.TestCompilationError = TestCompilationError;
class APIError extends Error {
    constructor(methodName, code, ...args) {
        let template = templates_1.default[code];
        template = APIError._prepareTemplateAndArgsIfNecessary(template, args);
        const rawMessage = render_template_1.default(template, ...args);
        super(render_template_1.default(templates_1.default[types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError], rawMessage));
        Object.assign(this, { code, data: args });
        // NOTE: `rawMessage` is used in error substitution if it occurs in test run.
        this.rawMessage = rawMessage;
        this.callsite = get_callsite_1.getCallsiteForMethod(methodName);
        // NOTE: We need property getters here because callsite can be replaced by an external code.
        // See https://github.com/DevExpress/testcafe/blob/v1.0.0/src/compiler/test-file/formats/raw.js#L22
        // Also we can't use an ES6 getter for the 'stack' property, because it will create a getter on the class prototype
        // that cannot override the instance property created by the Error parent class.
        Object.defineProperties(this, {
            'stack': {
                get: () => this._createStack(callsite_record_1.renderers.noColor)
            },
            'coloredStack': {
                get: () => this._createStack(callsite_record_1.renderers.default)
            }
        });
    }
    _renderCallsite(renderer) {
        if (!this.callsite)
            return '';
        // NOTE: Callsite will throw during rendering if it can't find a target file for the specified function or method:
        // https://github.com/inikulin/callsite-record/issues/2#issuecomment-223263941
        try {
            return this.callsite.renderSync({
                renderer: renderer,
                stackFilter: create_stack_filter_1.default(Error.stackTraceLimit)
            });
        }
        catch (error) {
            return '';
        }
    }
    _createStack(renderer) {
        const renderedCallsite = this._renderCallsite(renderer);
        if (!renderedCallsite)
            return this.message;
        return this.message + ERROR_SEPARATOR + renderedCallsite;
    }
    static _prepareTemplateAndArgsIfNecessary(template, args) {
        const lastArg = args.pop();
        if (lastArg instanceof ProcessTemplateInstruction)
            template = lastArg.processFn(template);
        else
            args.push(lastArg);
        return template;
    }
}
exports.APIError = APIError;
class ClientFunctionAPIError extends APIError {
    constructor(methodName, instantiationCallsiteName, code, ...args) {
        args.push(new ProcessTemplateInstruction(template => template.replace(/\{#instantiationCallsiteName\}/g, instantiationCallsiteName)));
        super(methodName, code, ...args);
    }
}
exports.ClientFunctionAPIError = ClientFunctionAPIError;
class CompositeError extends Error {
    constructor(errors) {
        super(errors.map(({ message }) => message).join(ERROR_SEPARATOR));
        this.stack = errors.map(({ stack }) => stack).join(ERROR_SEPARATOR);
        this.code = types_1.RUNTIME_ERRORS.compositeArgumentsError;
    }
}
exports.CompositeError = CompositeError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZXJyb3JzL3J1bnRpbWUvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxxREFBNEM7QUFDNUMsNERBQW9DO0FBQ3BDLGlGQUF1RDtBQUN2RCxrREFBdUQ7QUFDdkQsa0ZBQXlEO0FBQ3pELG9DQUEwQztBQUUxQyxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUM7QUFFL0IsTUFBTSwwQkFBMEI7SUFDNUIsWUFBYSxTQUFTO1FBQ2xCLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO0lBQy9CLENBQUM7Q0FDSjtBQUVELFNBQVM7QUFDVCxNQUFhLFlBQWEsU0FBUSxLQUFLO0lBQ25DLFlBQWEsR0FBRyxJQUFJO1FBQ2hCLE1BQU0sSUFBSSxHQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUM5QixNQUFNLFFBQVEsR0FBRyxtQkFBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWpDLEtBQUssQ0FBQyx5QkFBYyxDQUFDLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFekMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDMUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNoRCxDQUFDO0NBQ0o7QUFWRCxvQ0FVQztBQUVELE1BQWEsb0JBQXFCLFNBQVEsS0FBSztJQUMzQyxZQUFhLGFBQWE7UUFDdEIsTUFBTSxRQUFRLEdBQU8sbUJBQVMsQ0FBQyxzQkFBYyxDQUFDLDRCQUE0QixDQUFDLENBQUM7UUFDNUUsTUFBTSxZQUFZLEdBQUcsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRTlDLEtBQUssQ0FBQyx5QkFBYyxDQUFDLFFBQVEsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBRTlDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFO1lBQ2hCLElBQUksRUFBRSxzQkFBYyxDQUFDLDRCQUE0QjtZQUNqRCxJQUFJLEVBQUUsQ0FBRSxZQUFZLENBQUU7U0FDekIsQ0FBQyxDQUFDO1FBRUgsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQyxLQUFLLEdBQUcseUJBQWMsQ0FBQyxRQUFRLEVBQUUsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9ELENBQUM7Q0FDSjtBQWZELG9EQWVDO0FBRUQsTUFBYSxRQUFTLFNBQVEsS0FBSztJQUMvQixZQUFhLFVBQVUsRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJO1FBQ2xDLElBQUksUUFBUSxHQUFHLG1CQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFL0IsUUFBUSxHQUFHLFFBQVEsQ0FBQyxrQ0FBa0MsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFdkUsTUFBTSxVQUFVLEdBQUcseUJBQWMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUVyRCxLQUFLLENBQUMseUJBQWMsQ0FBQyxtQkFBUyxDQUFDLHNCQUFjLENBQUMsNEJBQTRCLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBRTFGLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRTFDLDZFQUE2RTtRQUM3RSxJQUFJLENBQUMsVUFBVSxHQUFJLFVBQVUsQ0FBQztRQUM5QixJQUFJLENBQUMsUUFBUSxHQUFNLG1DQUFvQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRXBELDRGQUE0RjtRQUM1RixtR0FBbUc7UUFDbkcsbUhBQW1IO1FBQ25ILGdGQUFnRjtRQUNoRixNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFO1lBQzFCLE9BQU8sRUFBRTtnQkFDTCxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQywyQkFBUyxDQUFDLE9BQU8sQ0FBQzthQUNsRDtZQUVELGNBQWMsRUFBRTtnQkFDWixHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQywyQkFBUyxDQUFDLE9BQU8sQ0FBQzthQUNsRDtTQUNKLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRCxlQUFlLENBQUUsUUFBUTtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVE7WUFDZCxPQUFPLEVBQUUsQ0FBQztRQUVkLGtIQUFrSDtRQUNsSCw4RUFBOEU7UUFDOUUsSUFBSTtZQUNBLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7Z0JBQzVCLFFBQVEsRUFBSyxRQUFRO2dCQUNyQixXQUFXLEVBQUUsNkJBQWlCLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQzthQUN4RCxDQUFDLENBQUM7U0FDTjtRQUNELE9BQU8sS0FBSyxFQUFFO1lBQ1YsT0FBTyxFQUFFLENBQUM7U0FDYjtJQUNMLENBQUM7SUFFRCxZQUFZLENBQUUsUUFBUTtRQUNsQixNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFeEQsSUFBSSxDQUFDLGdCQUFnQjtZQUNqQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7UUFFeEIsT0FBTyxJQUFJLENBQUMsT0FBTyxHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsQ0FBQztJQUM3RCxDQUFDO0lBRUQsTUFBTSxDQUFDLGtDQUFrQyxDQUFFLFFBQVEsRUFBRSxJQUFJO1FBQ3JELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUUzQixJQUFJLE9BQU8sWUFBWSwwQkFBMEI7WUFDN0MsUUFBUSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7O1lBRXZDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkIsT0FBTyxRQUFRLENBQUM7SUFDcEIsQ0FBQztDQUNKO0FBbkVELDRCQW1FQztBQUVELE1BQWEsc0JBQXVCLFNBQVEsUUFBUTtJQUNoRCxZQUFhLFVBQVUsRUFBRSx5QkFBeUIsRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJO1FBQzdELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSwwQkFBMEIsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsaUNBQWlDLEVBQUUseUJBQXlCLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFdEksS0FBSyxDQUFDLFVBQVUsRUFBRSxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBQ0o7QUFORCx3REFNQztBQUVELE1BQWEsY0FBZSxTQUFRLEtBQUs7SUFDckMsWUFBYSxNQUFNO1FBQ2YsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztRQUVsRSxJQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDcEUsSUFBSSxDQUFDLElBQUksR0FBSSxzQkFBYyxDQUFDLHVCQUF1QixDQUFDO0lBQ3hELENBQUM7Q0FDSjtBQVBELHdDQU9DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVyZXJzIH0gZnJvbSAnY2FsbHNpdGUtcmVjb3JkJztcbmltcG9ydCBURU1QTEFURVMgZnJvbSAnLi90ZW1wbGF0ZXMnO1xuaW1wb3J0IGNyZWF0ZVN0YWNrRmlsdGVyIGZyb20gJy4uL2NyZWF0ZS1zdGFjay1maWx0ZXInO1xuaW1wb3J0IHsgZ2V0Q2FsbHNpdGVGb3JNZXRob2QgfSBmcm9tICcuLi9nZXQtY2FsbHNpdGUnO1xuaW1wb3J0IHJlbmRlclRlbXBsYXRlIGZyb20gJy4uLy4uL3V0aWxzL3JlbmRlci10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgRVJST1JfU0VQQVJBVE9SID0gJ1xcblxcbic7XG5cbmNsYXNzIFByb2Nlc3NUZW1wbGF0ZUluc3RydWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvciAocHJvY2Vzc0ZuKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc0ZuID0gcHJvY2Vzc0ZuO1xuICAgIH1cbn1cblxuLy8gRXJyb3JzXG5leHBvcnQgY2xhc3MgR2VuZXJhbEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgICAgID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IFRFTVBMQVRFU1tjb2RlXTtcblxuICAgICAgICBzdXBlcihyZW5kZXJUZW1wbGF0ZSh0ZW1wbGF0ZSwgLi4uYXJncykpO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBjb2RlLCBkYXRhOiBhcmdzIH0pO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBHZW5lcmFsRXJyb3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRlc3RDb21waWxhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlICAgICA9IFRFTVBMQVRFU1tSVU5USU1FX0VSUk9SUy5jYW5ub3RQcmVwYXJlVGVzdHNEdWVUb0Vycm9yXTtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gb3JpZ2luYWxFcnJvci50b1N0cmluZygpO1xuXG4gICAgICAgIHN1cGVyKHJlbmRlclRlbXBsYXRlKHRlbXBsYXRlLCBlcnJvck1lc3NhZ2UpKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgICAgICAgIGNvZGU6IFJVTlRJTUVfRVJST1JTLmNhbm5vdFByZXBhcmVUZXN0c0R1ZVRvRXJyb3IsXG4gICAgICAgICAgICBkYXRhOiBbIGVycm9yTWVzc2FnZSBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE5PVEU6IHN0YWNrIGluY2x1ZGVzIG1lc3NhZ2UgYXMgd2VsbC5cbiAgICAgICAgdGhpcy5zdGFjayA9IHJlbmRlclRlbXBsYXRlKHRlbXBsYXRlLCBvcmlnaW5hbEVycm9yLnN0YWNrKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBUElFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWV0aG9kTmFtZSwgY29kZSwgLi4uYXJncykge1xuICAgICAgICBsZXQgdGVtcGxhdGUgPSBURU1QTEFURVNbY29kZV07XG5cbiAgICAgICAgdGVtcGxhdGUgPSBBUElFcnJvci5fcHJlcGFyZVRlbXBsYXRlQW5kQXJnc0lmTmVjZXNzYXJ5KHRlbXBsYXRlLCBhcmdzKTtcblxuICAgICAgICBjb25zdCByYXdNZXNzYWdlID0gcmVuZGVyVGVtcGxhdGUodGVtcGxhdGUsIC4uLmFyZ3MpO1xuXG4gICAgICAgIHN1cGVyKHJlbmRlclRlbXBsYXRlKFRFTVBMQVRFU1tSVU5USU1FX0VSUk9SUy5jYW5ub3RQcmVwYXJlVGVzdHNEdWVUb0Vycm9yXSwgcmF3TWVzc2FnZSkpO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBjb2RlLCBkYXRhOiBhcmdzIH0pO1xuXG4gICAgICAgIC8vIE5PVEU6IGByYXdNZXNzYWdlYCBpcyB1c2VkIGluIGVycm9yIHN1YnN0aXR1dGlvbiBpZiBpdCBvY2N1cnMgaW4gdGVzdCBydW4uXG4gICAgICAgIHRoaXMucmF3TWVzc2FnZSAgPSByYXdNZXNzYWdlO1xuICAgICAgICB0aGlzLmNhbGxzaXRlICAgID0gZ2V0Q2FsbHNpdGVGb3JNZXRob2QobWV0aG9kTmFtZSk7XG5cbiAgICAgICAgLy8gTk9URTogV2UgbmVlZCBwcm9wZXJ0eSBnZXR0ZXJzIGhlcmUgYmVjYXVzZSBjYWxsc2l0ZSBjYW4gYmUgcmVwbGFjZWQgYnkgYW4gZXh0ZXJuYWwgY29kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9EZXZFeHByZXNzL3Rlc3RjYWZlL2Jsb2IvdjEuMC4wL3NyYy9jb21waWxlci90ZXN0LWZpbGUvZm9ybWF0cy9yYXcuanMjTDIyXG4gICAgICAgIC8vIEFsc28gd2UgY2FuJ3QgdXNlIGFuIEVTNiBnZXR0ZXIgZm9yIHRoZSAnc3RhY2snIHByb3BlcnR5LCBiZWNhdXNlIGl0IHdpbGwgY3JlYXRlIGEgZ2V0dGVyIG9uIHRoZSBjbGFzcyBwcm90b3R5cGVcbiAgICAgICAgLy8gdGhhdCBjYW5ub3Qgb3ZlcnJpZGUgdGhlIGluc3RhbmNlIHByb3BlcnR5IGNyZWF0ZWQgYnkgdGhlIEVycm9yIHBhcmVudCBjbGFzcy5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICAgICAgJ3N0YWNrJzoge1xuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gdGhpcy5fY3JlYXRlU3RhY2socmVuZGVyZXJzLm5vQ29sb3IpXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnY29sb3JlZFN0YWNrJzoge1xuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gdGhpcy5fY3JlYXRlU3RhY2socmVuZGVyZXJzLmRlZmF1bHQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9yZW5kZXJDYWxsc2l0ZSAocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxzaXRlKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuXG4gICAgICAgIC8vIE5PVEU6IENhbGxzaXRlIHdpbGwgdGhyb3cgZHVyaW5nIHJlbmRlcmluZyBpZiBpdCBjYW4ndCBmaW5kIGEgdGFyZ2V0IGZpbGUgZm9yIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gb3IgbWV0aG9kOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaW5pa3VsaW4vY2FsbHNpdGUtcmVjb3JkL2lzc3Vlcy8yI2lzc3VlY29tbWVudC0yMjMyNjM5NDFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGxzaXRlLnJlbmRlclN5bmMoe1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiAgICByZW5kZXJlcixcbiAgICAgICAgICAgICAgICBzdGFja0ZpbHRlcjogY3JlYXRlU3RhY2tGaWx0ZXIoRXJyb3Iuc3RhY2tUcmFjZUxpbWl0KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlU3RhY2sgKHJlbmRlcmVyKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkQ2FsbHNpdGUgPSB0aGlzLl9yZW5kZXJDYWxsc2l0ZShyZW5kZXJlcik7XG5cbiAgICAgICAgaWYgKCFyZW5kZXJlZENhbGxzaXRlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlICsgRVJST1JfU0VQQVJBVE9SICsgcmVuZGVyZWRDYWxsc2l0ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX3ByZXBhcmVUZW1wbGF0ZUFuZEFyZ3NJZk5lY2Vzc2FyeSAodGVtcGxhdGUsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbGFzdEFyZyA9IGFyZ3MucG9wKCk7XG5cbiAgICAgICAgaWYgKGxhc3RBcmcgaW5zdGFuY2VvZiBQcm9jZXNzVGVtcGxhdGVJbnN0cnVjdGlvbilcbiAgICAgICAgICAgIHRlbXBsYXRlID0gbGFzdEFyZy5wcm9jZXNzRm4odGVtcGxhdGUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBhcmdzLnB1c2gobGFzdEFyZyk7XG5cbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIENsaWVudEZ1bmN0aW9uQVBJRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKG1ldGhvZE5hbWUsIGluc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWUsIGNvZGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgYXJncy5wdXNoKG5ldyBQcm9jZXNzVGVtcGxhdGVJbnN0cnVjdGlvbih0ZW1wbGF0ZSA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZVxcfS9nLCBpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lKSkpO1xuXG4gICAgICAgIHN1cGVyKG1ldGhvZE5hbWUsIGNvZGUsIC4uLmFyZ3MpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIENvbXBvc2l0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChlcnJvcnMpIHtcbiAgICAgICAgc3VwZXIoZXJyb3JzLm1hcCgoeyBtZXNzYWdlIH0pID0+IG1lc3NhZ2UpLmpvaW4oRVJST1JfU0VQQVJBVE9SKSk7XG5cbiAgICAgICAgdGhpcy5zdGFjayA9IGVycm9ycy5tYXAoKHsgc3RhY2sgfSkgPT4gc3RhY2spLmpvaW4oRVJST1JfU0VQQVJBVE9SKTtcbiAgICAgICAgdGhpcy5jb2RlICA9IFJVTlRJTUVfRVJST1JTLmNvbXBvc2l0ZUFyZ3VtZW50c0Vycm9yO1xuICAgIH1cbn1cbiJdfQ==