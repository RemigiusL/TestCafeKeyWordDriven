{"version":3,"sources":["../source/convertToJson.js"],"names":["data","schema","options","DEFAULT_OPTIONS","isColumnOriented","rowMap","validateSchema","transpose","columns","results","errors","i","length","result","read","push","error","row","rows","parseValue","getBlock","parseArray","rowIndex","object","key","schemaEntry","isNestedSchema","type","Array","isArray","rawValue","indexOf","undefined","value","notEmpty","array","map","_value","required","column","prop","Object","keys","parse","parseCustomValue","parseValueOfType","Error","JSON","stringify","validate","message","parsed","String","Number","isFinite","parseFloat","Date","parseInt","date","properties","Boolean","name","string","endCharacter","startIndex","substring","character","block","blocks","index","trim","_","entry"],"mappings":"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","file":"convertToJson.js","sourcesContent":["import parseDate from './parseDate'\r\nimport Integer, { isInteger } from './types/Integer'\r\nimport URL, { isURL } from './types/URL'\r\nimport Email, { isEmail } from './types/Email'\r\n\r\nconst DEFAULT_OPTIONS = {\r\n  isColumnOriented: false\r\n}\r\n\r\n/**\r\n * Convert 2D array to nested objects.\r\n * If row oriented data, row 0 is dotted key names.\r\n * Column oriented data is transposed.\r\n * @param {string[][]} data - An array of rows, each row being an array of cells.\r\n * @param {object} schema\r\n * @return {object[]}\r\n */\r\nexport default function(data, schema, options) {\r\n  if (options) {\r\n    options = {\r\n      ...DEFAULT_OPTIONS,\r\n      ...options\r\n    }\r\n  } else {\r\n    options = DEFAULT_OPTIONS\r\n  }\r\n\r\n  const {\r\n    isColumnOriented,\r\n    rowMap\r\n  } = options\r\n\r\n  validateSchema(schema)\r\n\r\n  if (isColumnOriented) {\r\n    data = transpose(data)\r\n  }\r\n\r\n  const columns = data[0]\r\n\r\n  const results = []\r\n  const errors = []\r\n\r\n  for (let i = 1; i < data.length; i++) {\r\n    const result = read(schema, data[i], i - 1, columns, errors, options)\r\n    if (result) {\r\n      results.push(result)\r\n    }\r\n  }\r\n\r\n  // Correct error rows.\r\n  if (rowMap) {\r\n    for (const error of errors) {\r\n      error.row = rowMap[error.row] + 1\r\n    }\r\n  }\r\n\r\n  return {\r\n    rows: results,\r\n    errors\r\n  }\r\n}\r\n\r\nfunction read(schema, row, rowIndex, columns, errors, options) {\r\n  const object = {}\r\n  for (const key of Object.keys(schema)) {\r\n    const schemaEntry = schema[key]\r\n    const isNestedSchema = typeof schemaEntry.type === 'object' && !Array.isArray(schemaEntry.type)\r\n    let rawValue = row[columns.indexOf(key)]\r\n    if (rawValue === undefined) {\r\n      rawValue = null\r\n    }\r\n    let value\r\n    let error\r\n    if (isNestedSchema) {\r\n      value = read(schemaEntry.type, row, rowIndex, columns, errors, options)\r\n    } else {\r\n      if (rawValue === null) {\r\n        value = null\r\n      }\r\n      else if (Array.isArray(schemaEntry.type)) {\r\n        let notEmpty = false\r\n        const array = parseArray(rawValue).map((_value) => {\r\n          const result = parseValue(_value, schemaEntry, options)\r\n          if (result.error) {\r\n            value = _value\r\n            error = result.error\r\n          }\r\n          if (result.value !== null) {\r\n            notEmpty = true\r\n          }\r\n          return result.value\r\n        })\r\n        if (!error) {\r\n          value = notEmpty ? array : null\r\n        }\r\n      } else {\r\n        const result = parseValue(rawValue, schemaEntry, options)\r\n        error = result.error\r\n        value = error ? rawValue : result.value\r\n      }\r\n    }\r\n    if (!error && value === null && schemaEntry.required) {\r\n      error = 'required'\r\n    }\r\n    if (error) {\r\n      error = {\r\n        error,\r\n        row: rowIndex + 1,\r\n        column: key,\r\n        value\r\n      }\r\n      if (schemaEntry.type) {\r\n        error.type = schemaEntry.type\r\n      }\r\n      errors.push(error)\r\n    } else if (value !== null) {\r\n      object[schemaEntry.prop] = value\r\n    }\r\n  }\r\n  if (Object.keys(object).length > 0) {\r\n    return object\r\n  }\r\n  return null\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {object} schemaEntry\r\n * @return {{ value: any, error: string }}\r\n */\r\nexport function parseValue(value, schemaEntry, options) {\r\n  if (value === null) {\r\n    return { value: null }\r\n  }\r\n  let result\r\n  if (schemaEntry.parse) {\r\n    result = parseCustomValue(value, schemaEntry.parse)\r\n  } else if (schemaEntry.type) {\r\n    result = parseValueOfType(value, Array.isArray(schemaEntry.type) ? schemaEntry.type[0] : schemaEntry.type, options)\r\n  } else {\r\n    throw new Error('Invalid schema entry: no .type and no .parse():\\n\\n' + JSON.stringify(schemaEntry, null, 2))\r\n  }\r\n  // If errored then return the error.\r\n  if (result.error) {\r\n    return result\r\n  }\r\n  if (result.value !== null && schemaEntry.validate) {\r\n    try {\r\n      schemaEntry.validate(result.value)\r\n    } catch (error) {\r\n      return { error: error.message }\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * Converts textual value to a custom value using supplied `.parse()`.\r\n * @param  {string} value\r\n * @param  {function} parse\r\n * @return {{ value: any, error: string }}\r\n */\r\nfunction parseCustomValue(value, parse) {\r\n  try {\r\n    let parsed = parse(value)\r\n    if (parsed === undefined) {\r\n      return { value: null }\r\n    }\r\n    return { value: parsed }\r\n  } catch (error) {\r\n    return { error: error.message }\r\n  }\r\n}\r\n\r\n/**\r\n * Converts textual value to a javascript typed value.\r\n * @param  {string} value\r\n * @param  {} type\r\n * @return {{ value: (string|number|Date|boolean), error: string }}\r\n */\r\nfunction parseValueOfType(value, type, options) {\r\n  switch (type) {\r\n    case String:\r\n      return { value }\r\n\r\n    case Number:\r\n    case 'Integer':\r\n    case Integer:\r\n      // The global isFinite() function determines\r\n      // whether the passed value is a finite number.\r\n      // If  needed, the parameter is first converted to a number.\r\n      if (!isFinite(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      if (type === Integer && !isInteger(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      // Convert strings to numbers.\r\n      // Just an additional feature.\r\n      // Won't happen when called from `readXlsx()`.\r\n      if (typeof value === 'string') {\r\n        value = parseFloat(value)\r\n      }\r\n      return { value }\r\n\r\n    case 'URL':\r\n    case URL:\r\n      if (!isURL(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case 'Email':\r\n    case Email:\r\n      if (!isEmail(value)) {\r\n        return { error: 'invalid' }\r\n      }\r\n      return { value }\r\n\r\n    case Date:\r\n      // XLSX has no specific format for dates.\r\n      // Sometimes a date can be heuristically detected.\r\n      // https://github.com/catamphetamine/read-excel-file/issues/3#issuecomment-395770777\r\n      if (value instanceof Date) {\r\n        return { value }\r\n      }\r\n      if (typeof value === 'number') {\r\n        if (!isFinite(value)) {\r\n          return { error: 'invalid' }\r\n        }\r\n        value = parseInt(value)\r\n        const date = parseDate(value, options.properties)\r\n        if (!date) {\r\n          return { error: 'invalid' }\r\n        }\r\n        return { value: date }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    case Boolean:\r\n      if (typeof value === 'boolean') {\r\n        return { value }\r\n      }\r\n      return { error: 'invalid' }\r\n\r\n    default:\r\n      throw new Error(`Unknown schema type: ${type && type.name || type}`)\r\n  }\r\n}\r\n\r\nexport function getBlock(string, endCharacter, startIndex) {\r\n  let i = 0\r\n  let substring = ''\r\n  let character\r\n  while (startIndex + i < string.length) {\r\n    const character = string[startIndex + i]\r\n    if (character === endCharacter) {\r\n      return [substring, i]\r\n    }\r\n    else if (character === '\"') {\r\n      const block = getBlock(string, '\"', startIndex + i + 1)\r\n      substring += block[0]\r\n      i += '\"'.length + block[1] + '\"'.length\r\n    }\r\n    else {\r\n      substring += character\r\n      i++\r\n    }\r\n  }\r\n  return [substring, i]\r\n}\r\n\r\nexport function parseArray(string) {\r\n  const blocks = []\r\n  let index = 0\r\n  while (index < string.length) {\r\n    const [substring, length] = getBlock(string, ',', index)\r\n    index += length + ','.length\r\n    blocks.push(substring.trim())\r\n  }\r\n  return blocks\r\n}\r\n\r\n// Transpose a 2D array.\r\n// https://stackoverflow.com/questions/17428587/transposing-a-2d-array-in-javascript\r\nconst transpose = array => array[0].map((_, i) => array.map(row => row[i]))\r\n\r\nfunction validateSchema(schema) {\r\n  for (const key of Object.keys(schema)) {\r\n    const entry = schema[key]\r\n    if (!entry.prop) {\r\n      throw new Error(`\"prop\" not defined for schema entry \"${key}\".`)\r\n    }\r\n  }\r\n}"]}